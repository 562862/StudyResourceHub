<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>自动化人工智能期末复习笔记</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Microsoft YaHei', 'PingFang SC', 'Helvetica Neue', Arial, sans-serif;
            line-height: 1.8;
            color: #333;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            padding: 20px;
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
            background: white;
            border-radius: 15px;
            box-shadow: 0 10px 40px rgba(0,0,0,0.2);
            overflow: hidden;
        }

        .header {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 40px;
            text-align: center;
        }

        .header h1 {
            font-size: 2.5em;
            margin-bottom: 10px;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.3);
        }

        .header p {
            font-size: 1.1em;
            opacity: 0.9;
        }

        .sidebar {
            position: fixed;
            left: 20px;
            top: 150px;
            width: 250px;
            background: white;
            border-radius: 10px;
            padding: 20px;
            box-shadow: 0 5px 20px rgba(0,0,0,0.1);
            max-height: calc(100vh - 170px);
            overflow-y: auto;
            z-index: 100;
        }

        .sidebar h3 {
            color: #667eea;
            margin-bottom: 15px;
            font-size: 1.2em;
            border-bottom: 2px solid #667eea;
            padding-bottom: 10px;
        }

        .sidebar ul {
            list-style: none;
        }

        .sidebar li {
            margin: 8px 0;
        }

        .sidebar a {
            color: #555;
            text-decoration: none;
            display: block;
            padding: 5px 10px;
            border-radius: 5px;
            transition: all 0.3s;
            font-size: 0.95em;
        }

        .sidebar a:hover {
            background: #667eea;
            color: white;
            transform: translateX(5px);
        }

        .content {
            margin-left: 290px;
            padding: 40px;
        }

        .section {
            margin-bottom: 40px;
            padding: 30px;
            background: #f8f9fa;
            border-radius: 10px;
            border-left: 5px solid #667eea;
        }

        h2 {
            color: #667eea;
            font-size: 2em;
            margin-bottom: 20px;
            padding-bottom: 10px;
            border-bottom: 3px solid #667eea;
        }

        h3 {
            color: #764ba2;
            font-size: 1.5em;
            margin: 25px 0 15px 0;
        }

        h4 {
            color: #555;
            font-size: 1.2em;
            margin: 20px 0 10px 0;
        }

        p {
            margin: 15px 0;
            text-align: justify;
        }

        ul, ol {
            margin: 15px 0 15px 30px;
        }

        li {
            margin: 8px 0;
        }

        strong {
            color: #667eea;
            font-weight: 600;
        }

        .formula {
            background: #fff;
            border: 2px solid #667eea;
            border-radius: 8px;
            padding: 15px;
            margin: 20px 0;
            font-family: 'Courier New', monospace;
            font-size: 1.1em;
            text-align: center;
            box-shadow: 0 3px 10px rgba(102, 126, 234, 0.1);
        }

        .example {
            background: #fff3cd;
            border-left: 5px solid #ffc107;
            padding: 20px;
            margin: 20px 0;
            border-radius: 5px;
        }

        .example h4 {
            color: #856404;
            margin-top: 0;
        }

        .solution {
            background: #d1ecf1;
            border-left: 5px solid #17a2b8;
            padding: 20px;
            margin: 20px 0;
            border-radius: 5px;
        }

        .solution h5 {
            color: #0c5460;
            margin-bottom: 10px;
        }

        table {
            width: 100%;
            border-collapse: collapse;
            margin: 20px 0;
            background: white;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
            border-radius: 8px;
            overflow: hidden;
        }

        th {
            background: #667eea;
            color: white;
            padding: 15px;
            text-align: left;
            font-weight: 600;
        }

        td {
            padding: 12px 15px;
            border-bottom: 1px solid #ddd;
        }

        tr:hover {
            background: #f5f5f5;
        }

        .code-block {
            background: #282c34;
            color: #abb2bf;
            padding: 20px;
            border-radius: 8px;
            margin: 20px 0;
            overflow-x: auto;
            font-family: 'Consolas', 'Monaco', monospace;
            font-size: 0.95em;
            line-height: 1.6;
            box-shadow: 0 3px 10px rgba(0,0,0,0.2);
        }

        .highlight {
            background: #fffbcc;
            padding: 2px 6px;
            border-radius: 3px;
            font-weight: 500;
        }

        .tip {
            background: #d4edda;
            border-left: 5px solid #28a745;
            padding: 15px;
            margin: 20px 0;
            border-radius: 5px;
        }

        .tip::before {
            content: "💡 提示：";
            font-weight: bold;
            color: #155724;
        }

        .warning {
            background: #f8d7da;
            border-left: 5px solid #dc3545;
            padding: 15px;
            margin: 20px 0;
            border-radius: 5px;
        }

        .warning::before {
            content: "⚠️ 注意：";
            font-weight: bold;
            color: #721c24;
        }

        .checklist {
            list-style: none;
            margin: 20px 0;
        }

        .checklist li {
            padding: 10px;
            margin: 10px 0;
            background: white;
            border-radius: 5px;
            box-shadow: 0 2px 5px rgba(0,0,0,0.1);
        }

        .checklist li::before {
            content: "☐ ";
            font-size: 1.3em;
            margin-right: 10px;
            color: #667eea;
        }

        .back-to-top {
            position: fixed;
            bottom: 30px;
            right: 30px;
            background: #667eea;
            color: white;
            width: 50px;
            height: 50px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            box-shadow: 0 5px 15px rgba(102, 126, 234, 0.4);
            transition: all 0.3s;
            text-decoration: none;
            font-size: 1.5em;
        }

        .back-to-top:hover {
            background: #764ba2;
            transform: translateY(-5px);
        }

        @media print {
            body {
                background: white;
                padding: 0;
            }
            .sidebar, .back-to-top {
                display: none;
            }
            .content {
                margin-left: 0;
            }
        }

        @media (max-width: 768px) {
            .sidebar {
                display: none;
            }
            .content {
                margin-left: 0;
                padding: 20px;
            }
            .header h1 {
                font-size: 1.8em;
            }
        }

        .formula-box {
            background: linear-gradient(135deg, #e0c3fc 0%, #8ec5fc 100%);
            border-radius: 10px;
            padding: 20px;
            margin: 20px 0;
            box-shadow: 0 5px 15px rgba(0,0,0,0.1);
        }

        .formula-box h4 {
            color: #4a148c;
            margin-top: 0;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>自动化人工智能期末复习笔记</h1>
            <p>完整版 · 含例题详解 · 祝考试顺利</p>
        </div>

        <div class="sidebar">
            <h3>目录导航</h3>
            <ul>
                <li><a href="#section1">1. 人工智能基础概念</a></li>
                <li><a href="#section2">2. 机器学习基础</a></li>
                <li><a href="#section3">3. 监督学习</a></li>
                <li><a href="#section4">4. 神经网络与深度学习</a></li>
                <li><a href="#section5">5. 无监督学习</a></li>
                <li><a href="#section6">6. 强化学习</a></li>
                <li><a href="#section7">7. 自动化应用场景</a></li>
                <li><a href="#section8">8. 实战综合题</a></li>
                <li><a href="#section9">9. 常见错误与调试</a></li>
                <li><a href="#section10">10. 期末题型预测</a></li>
                <li><a href="#section11">11. 快速记忆口诀</a></li>
                <li><a href="#section12">12. 重点公式汇总</a></li>
                <li><a href="#section13">13. 学习建议</a></li>
                <li><a href="#section14">14. 考前检查清单</a></li>
            </ul>
        </div>

        <div class="content">
            <div id="section1" class="section">
                <h2>1. 人工智能基础概念</h2>

                <h3>1.1 什么是人工智能？</h3>
                <p><strong>定义</strong>：人工智能(Artificial Intelligence, AI)是研究、开发用于模拟、延伸和扩展人的智能的理论、方法、技术及应用系统的一门新的技术科学。</p>

                <p><strong>核心目标</strong>：让机器像人一样思考、学习、决策和解决问题。</p>

                <h4>AI的三个层次</h4>
                <ul>
                    <li><strong>弱人工智能(ANI)</strong>：专注于特定任务（如语音识别、图像分类）</li>
                    <li><strong>强人工智能(AGI)</strong>：具有人类级别的通用智能（目前尚未实现）</li>
                    <li><strong>超人工智能(ASI)</strong>：超越人类智能的AI（理论阶段）</li>
                </ul>

                <h3>1.2 AI的发展历程</h3>
                <ul>
                    <li><strong>1956年</strong>：达特茅斯会议，AI诞生</li>
                    <li><strong>1980-1990年代</strong>：专家系统兴起</li>
                    <li><strong>2010年代至今</strong>：深度学习革命，大数据驱动</li>
                </ul>
            </div>

            <div id="section2" class="section">
                <h2>2. 机器学习基础</h2>

                <h3>2.1 什么是机器学习？</h3>
                <p><strong>定义</strong>：机器学习是一种让计算机从数据中自动学习规律，而不需要明确编程的方法。</p>
                <p><strong>核心思想</strong>：通过大量数据训练模型，使其能够对新数据做出预测或决策。</p>

                <h3>2.2 机器学习的分类</h3>

                <h4>(1) 监督学习 (Supervised Learning)</h4>
                <ul>
                    <li><strong>特点</strong>：训练数据有标签（正确答案）</li>
                    <li><strong>目标</strong>：学习输入到输出的映射关系</li>
                    <li><strong>应用</strong>：分类、回归</li>
                </ul>

                <h4>(2) 无监督学习 (Unsupervised Learning)</h4>
                <ul>
                    <li><strong>特点</strong>：训练数据没有标签</li>
                    <li><strong>目标</strong>：发现数据中的隐藏结构</li>
                    <li><strong>应用</strong>：聚类、降维</li>
                </ul>

                <h4>(3) 强化学习 (Reinforcement Learning)</h4>
                <ul>
                    <li><strong>特点</strong>：通过与环境交互获得奖励或惩罚</li>
                    <li><strong>目标</strong>：学习最优策略</li>
                    <li><strong>应用</strong>：游戏AI、机器人控制</li>
                </ul>

                <h3>2.3 核心概念</h3>
                <p><strong>特征 (Feature)</strong>：描述数据的属性或变量<br>
                例：预测房价时，特征包括面积、地段、房龄等</p>

                <p><strong>标签 (Label)</strong>：监督学习中的"正确答案"<br>
                例：房价预测中的实际价格</p>

                <p><strong>训练集 (Training Set)</strong>：用于训练模型的数据</p>
                <p><strong>测试集 (Test Set)</strong>：用于评估模型性能的数据</p>

                <div class="warning">
                    <strong>过拟合 (Overfitting)</strong>：模型在训练集上表现很好，但在测试集上表现差<br>
                    原因：模型过于复杂，记住了训练数据的噪声
                </div>

                <div class="tip">
                    <strong>欠拟合 (Underfitting)</strong>：模型在训练集和测试集上都表现差<br>
                    原因：模型过于简单，无法捕捉数据规律
                </div>
            </div>

            <div id="section3" class="section">
                <h2>3. 监督学习</h2>

                <h3>3.1 线性回归 (Linear Regression)</h3>

                <h4>基本原理</h4>
                <p>预测连续值输出，假设输入和输出之间存在线性关系。</p>

                <div class="formula">
                    y = w₁x₁ + w₂x₂ + ... + wₙxₙ + b
                </div>

                <ul>
                    <li>y：预测值</li>
                    <li>x₁, x₂, ..., xₙ：特征</li>
                    <li>w₁, w₂, ..., wₙ：权重（参数）</li>
                    <li>b：偏置（截距）</li>
                </ul>

                <div class="formula">
                    <strong>损失函数（均方误差 MSE）：</strong><br>
                    MSE = (1/m) Σ(yᵢ - ŷᵢ)²
                </div>

                <div class="example">
                    <h4>例题1：简单线性回归</h4>
                    <p><strong>问题</strong>：根据学习时间预测考试成绩</p>

                    <table>
                        <tr>
                            <th>学习时间(小时)</th>
                            <th>考试成绩(分)</th>
                        </tr>
                        <tr><td>1</td><td>50</td></tr>
                        <tr><td>2</td><td>55</td></tr>
                        <tr><td>3</td><td>65</td></tr>
                        <tr><td>4</td><td>70</td></tr>
                        <tr><td>5</td><td>85</td></tr>
                    </table>

                    <p>假设学习到的模型为：<span class="highlight">成绩 = 8.5 × 学习时间 + 42</span></p>

                    <p><strong>问：如果学习6小时，预测成绩是多少？</strong></p>
                </div>

                <div class="solution">
                    <h5>解答：</h5>
                    <div class="code-block">成绩 = 8.5 × 6 + 42
     = 51 + 42
     = 93分</div>

                    <p><strong>问：计算前3个样本的MSE</strong></p>
                    <div class="code-block">样本1预测值：8.5×1 + 42 = 50.5，误差²=(50-50.5)² = 0.25
样本2预测值：8.5×2 + 42 = 59，误差²=(55-59)² = 16
样本3预测值：8.5×3 + 42 = 67.5，误差²=(65-67.5)² = 6.25

MSE = (0.25 + 16 + 6.25) / 3 = 7.5</div>
                </div>

                <h3>3.2 逻辑回归 (Logistic Regression)</h3>

                <h4>基本原理</h4>
                <p>用于二分类问题，输出是概率值（0到1之间）。</p>

                <div class="formula">
                    P(y=1|x) = 1 / (1 + e<sup>-z</sup>)<br>
                    其中 z = w₁x₁ + w₂x₂ + ... + wₙxₙ + b
                </div>

                <p>这个函数叫做<strong>Sigmoid函数</strong>，将线性输出转换为概率。</p>

                <div class="example">
                    <h4>例题2：垃圾邮件分类</h4>
                    <p><strong>问题</strong>：根据邮件特征判断是否为垃圾邮件</p>

                    <p>特征：</p>
                    <ul>
                        <li>x₁：包含"中奖"词汇的次数</li>
                        <li>x₂：包含链接的数量</li>
                    </ul>

                    <p>假设学习到的模型为：z = 0.8x₁ + 0.5x₂ - 2</p>

                    <p><strong>问：一封邮件包含3次"中奖"，2个链接，是垃圾邮件的概率是多少？</strong></p>
                </div>

                <div class="solution">
                    <h5>解答：</h5>
                    <div class="code-block">步骤1：计算z
z = 0.8×3 + 0.5×2 - 2
  = 2.4 + 1 - 2
  = 1.4

步骤2：计算概率
P(垃圾邮件) = 1 / (1 + e^(-1.4))
            = 1 / (1 + 0.2466)
            = 1 / 1.2466
            ≈ 0.802

答：该邮件是垃圾邮件的概率约为80.2%</div>

                    <p><strong>决策规则</strong>：通常P≥0.5判定为垃圾邮件，P&lt;0.5判定为正常邮件。</p>
                </div>

                <h3>3.3 决策树 (Decision Tree)</h3>

                <h4>基本原理</h4>
                <p>通过一系列if-else规则进行分类或回归，像一个倒置的树结构。</p>

                <p><strong>关键概念</strong>：</p>
                <ul>
                    <li><strong>根节点</strong>：最顶层的节点</li>
                    <li><strong>内部节点</strong>：决策节点（问问题）</li>
                    <li><strong>叶节点</strong>：最终决策结果</li>
                    <li><strong>信息增益</strong>：选择最佳分割特征的标准</li>
                </ul>

                <h3>3.4 支持向量机 (SVM)</h3>

                <h4>基本原理</h4>
                <p>找到一个最优的超平面（决策边界），使得两类数据之间的间隔最大。</p>

                <p><strong>核心概念</strong>：</p>
                <ul>
                    <li><strong>支持向量</strong>：离决策边界最近的数据点</li>
                    <li><strong>间隔(Margin)</strong>：决策边界到支持向量的距离</li>
                    <li><strong>核函数</strong>：处理非线性可分问题</li>
                </ul>

                <h3>3.5 模型评估指标</h3>

                <h4>混淆矩阵</h4>
                <table>
                    <tr>
                        <th></th>
                        <th>预测为正</th>
                        <th>预测为负</th>
                    </tr>
                    <tr>
                        <td><strong>实际为正</strong></td>
                        <td>TP (真正例)</td>
                        <td>FN (假负例)</td>
                    </tr>
                    <tr>
                        <td><strong>实际为负</strong></td>
                        <td>FP (假正例)</td>
                        <td>TN (真负例)</td>
                    </tr>
                </table>

                <div class="formula-box">
                    <h4>评估指标公式</h4>
                    <div class="formula">
                        准确率 (Accuracy) = (TP + TN) / (TP + TN + FP + FN)
                    </div>
                    <div class="formula">
                        精确率 (Precision) = TP / (TP + FP)<br>
                        <small>含义：预测为正的样本中，真正为正的比例</small>
                    </div>
                    <div class="formula">
                        召回率 (Recall) = TP / (TP + FN)<br>
                        <small>含义：实际为正的样本中，被正确预测的比例</small>
                    </div>
                    <div class="formula">
                        F1分数 = 2 × (Precision × Recall) / (Precision + Recall)
                    </div>
                </div>

                <div class="example">
                    <h4>例题5：医疗诊断评估</h4>
                    <p><strong>问题</strong>：一个疾病检测模型对100个病人进行诊断：</p>
                    <ul>
                        <li>实际患病：30人</li>
                        <li>实际健康：70人</li>
                        <li>预测患病且实际患病：25人</li>
                        <li>预测患病但实际健康：10人</li>
                        <li>预测健康但实际患病：5人</li>
                        <li>预测健康且实际健康：60人</li>
                    </ul>
                    <p><strong>问：计算准确率、精确率、召回率和F1分数</strong></p>
                </div>

                <div class="solution">
                    <h5>解答：</h5>
                    <div class="code-block">首先构建混淆矩阵：
                预测患病  预测健康
实际患病    25 (TP)   5 (FN)
实际健康    10 (FP)   60 (TN)

1. 准确率
Accuracy = (25 + 60) / 100 = 0.85 = 85%

2. 精确率
Precision = 25 / (25 + 10) = 25/35 ≈ 0.714 = 71.4%
含义：在预测患病的35人中，25人真的患病

3. 召回率
Recall = 25 / (25 + 5) = 25/30 ≈ 0.833 = 83.3%
含义：在实际患病的30人中，25人被检测出来

4. F1分数
F1 = 2 × (0.714 × 0.833) / (0.714 + 0.833)
   = 2 × 0.595 / 1.547
   ≈ 0.769 = 76.9%</div>

                    <div class="warning">
                        <strong>解读</strong>：<br>
                        准确率85%看起来不错，但召回率83.3%意味着有5个患病者被漏诊（这在医疗中很严重！）<br>
                        在医疗场景中，召回率比精确率更重要
                    </div>
                </div>
            </div>

            <div id="section4" class="section">
                <h2>4. 神经网络与深度学习</h2>

                <h3>4.1 神经网络基础</h3>

                <h4>什么是神经网络？</h4>
                <p>模拟人脑神经元结构的计算模型，由大量简单的神经元相互连接组成。</p>

                <p><strong>基本组成</strong>：</p>
                <ol>
                    <li><strong>输入层</strong>：接收原始数据</li>
                    <li><strong>隐藏层</strong>：进行特征提取和变换</li>
                    <li><strong>输出层</strong>：产生最终结果</li>
                </ol>

                <h4>单个神经元的工作原理</h4>
                <div class="code-block">输入: x₁, x₂, ..., xₙ
权重: w₁, w₂, ..., wₙ
偏置: b

步骤1：加权求和
z = w₁x₁ + w₂x₂ + ... + wₙxₙ + b

步骤2：激活函数
a = f(z)

常用激活函数：
- ReLU: f(z) = max(0, z)
- Sigmoid: f(z) = 1/(1+e^(-z))
- Tanh: f(z) = (e^z - e^(-z))/(e^z + e^(-z))</div>

                <div class="example">
                    <h4>例题6：简单神经元计算</h4>
                    <p><strong>问题</strong>：一个神经元有3个输入，使用ReLU激活函数</p>
                    <ul>
                        <li>输入：x₁=2, x₂=-1, x₃=3</li>
                        <li>权重：w₁=0.5, w₂=0.3, w₃=-0.2</li>
                        <li>偏置：b=1</li>
                    </ul>
                    <p><strong>问：计算该神经元的输出</strong></p>
                </div>

                <div class="solution">
                    <h5>解答：</h5>
                    <div class="code-block">步骤1：计算加权和
z = 0.5×2 + 0.3×(-1) + (-0.2)×3 + 1
  = 1 - 0.3 - 0.6 + 1
  = 1.1

步骤2：应用ReLU激活函数
ReLU(z) = max(0, 1.1) = 1.1

答：该神经元的输出为1.1</div>
                </div>

                <h3>4.2 反向传播算法</h3>

                <h4>基本原理</h4>
                <p>通过计算损失函数对每个权重的梯度，逐层向后传播，更新网络参数。</p>

                <p><strong>训练步骤</strong>：</p>
                <ol>
                    <li><strong>前向传播</strong>：输入数据，计算预测值</li>
                    <li><strong>计算损失</strong>：比较预测值和真实值</li>
                    <li><strong>反向传播</strong>：计算梯度</li>
                    <li><strong>参数更新</strong>：根据梯度调整权重和偏置</li>
                </ol>

                <div class="formula">
                    <strong>梯度下降公式：</strong><br>
                    w = w - α × ∂Loss/∂w
                </div>
                <ul>
                    <li>α：学习率（控制更新步长）</li>
                    <li>∂Loss/∂w：损失函数对权重的梯度</li>
                </ul>

                <h3>4.3 卷积神经网络 (CNN)</h3>

                <h4>基本原理</h4>
                <p>专门用于处理图像数据的神经网络，通过卷积操作提取图像特征。</p>

                <p><strong>核心组件</strong>：</p>
                <ol>
                    <li><strong>卷积层 (Convolutional Layer)</strong>：用卷积核（滤波器）扫描图像，提取局部特征（边缘、纹理等）</li>
                    <li><strong>池化层 (Pooling Layer)</strong>：降低特征图的维度，常用最大池化(Max Pooling)</li>
                    <li><strong>全连接层 (Fully Connected Layer)</strong>：将特征映射到最终输出</li>
                </ol>

                <h3>4.4 循环神经网络 (RNN)</h3>

                <h4>基本原理</h4>
                <p>专门处理序列数据（如文本、时间序列），具有记忆功能。</p>

                <p><strong>核心特点</strong>：</p>
                <ul>
                    <li>输出不仅依赖当前输入，还依赖之前的输入</li>
                    <li>有隐藏状态(hidden state)存储历史信息</li>
                </ul>

                <div class="formula">
                    <strong>RNN计算公式：</strong><br>
                    h_t = f(W_h × h_{t-1} + W_x × x_t + b)<br>
                    y_t = W_y × h_t + b_y
                </div>
            </div>

            <div id="section5" class="section">
                <h2>5. 无监督学习</h2>

                <h3>5.1 K-均值聚类 (K-Means)</h3>

                <h4>基本原理</h4>
                <p>将数据分成K个簇，使得同一簇内的数据点尽可能相似，不同簇的数据点尽可能不同。</p>

                <p><strong>算法步骤</strong>：</p>
                <ol>
                    <li>随机初始化K个聚类中心</li>
                    <li>将每个数据点分配到最近的聚类中心</li>
                    <li>更新聚类中心（计算每个簇内所有点的平均值）</li>
                    <li>重复步骤2-3，直到聚类中心不再变化</li>
                </ol>

                <div class="formula">
                    <strong>距离计算（欧氏距离）：</strong><br>
                    d = √[(x₁-y₁)² + (x₂-y₂)² + ... + (xₙ-yₙ)²]
                </div>

                <h3>5.2 主成分分析 (PCA)</h3>

                <h4>基本原理</h4>
                <p>降维技术，将高维数据投影到低维空间，同时保留最重要的信息（最大方差）。</p>

                <p><strong>核心思想</strong>：</p>
                <ul>
                    <li>找到数据变化最大的方向（主成分）</li>
                    <li>用较少的主成分表示原始数据</li>
                </ul>

                <p><strong>应用场景</strong>：</p>
                <ul>
                    <li>数据可视化（降到2D或3D）</li>
                    <li>特征压缩</li>
                    <li>去除噪声</li>
                </ul>
            </div>

            <div id="section6" class="section">
                <h2>6. 强化学习</h2>

                <h3>6.1 基本概念</h3>

                <p><strong>定义</strong>：智能体(Agent)通过与环境(Environment)交互，学习最优策略以最大化累积奖励。</p>

                <p><strong>核心要素</strong>：</p>
                <ol>
                    <li><strong>状态 (State, S)</strong>：环境的描述</li>
                    <li><strong>动作 (Action, A)</strong>：智能体可执行的操作</li>
                    <li><strong>奖励 (Reward, R)</strong>：环境对动作的反馈</li>
                    <li><strong>策略 (Policy, π)</strong>：从状态到动作的映射</li>
                    <li><strong>价值函数 (Value Function, V)</strong>：预期累积奖励</li>
                </ol>

                <div class="tip">
                    <strong>工作流程</strong>：<br>
                    智能体观察状态 → 选择动作 → 执行动作 → 获得奖励 → 环境变化 → 新状态 → ...
                </div>

                <h3>6.2 Q-Learning算法</h3>

                <h4>基本原理</h4>
                <p>学习一个Q值表，Q(s,a)表示在状态s下执行动作a的长期价值。</p>

                <div class="formula-box">
                    <h4>Q值更新公式</h4>
                    <div class="formula">
                        Q(s,a) = Q(s,a) + α[r + γ×max Q(s',a') - Q(s,a)]
                    </div>
                    <ul>
                        <li>α：学习率（0-1之间）</li>
                        <li>r：立即奖励</li>
                        <li>γ：折扣因子（0-1之间）</li>
                        <li>s'：新状态</li>
                        <li>max Q(s',a')：新状态下最佳动作的Q值</li>
                    </ul>
                </div>

                <h3>6.3 探索与利用</h3>

                <p><strong>探索(Exploration)</strong>：尝试新动作，发现更好策略</p>
                <p><strong>利用(Exploitation)</strong>：选择已知最佳动作，获得高奖励</p>

                <div class="tip">
                    <strong>ε-贪心策略</strong>：<br>
                    以概率ε随机选择动作（探索）<br>
                    以概率1-ε选择最佳动作（利用）
                </div>
            </div>

            <div id="section7" class="section">
                <h2>7. 自动化应用场景</h2>

                <h3>7.1 计算机视觉</h3>
                <p><strong>应用领域</strong>：</p>
                <ul>
                    <li>图像分类（识别图片内容）</li>
                    <li>目标检测（定位物体位置）</li>
                    <li>人脸识别</li>
                    <li>自动驾驶</li>
                </ul>
                <p><strong>典型技术</strong>：CNN、YOLO、ResNet</p>

                <h3>7.2 自然语言处理</h3>
                <p><strong>应用领域</strong>：</p>
                <ul>
                    <li>机器翻译</li>
                    <li>文本分类（情感分析、垃圾邮件检测）</li>
                    <li>问答系统</li>
                    <li>文本生成</li>
                </ul>
                <p><strong>典型技术</strong>：RNN、LSTM、Transformer、BERT</p>

                <h3>7.3 推荐系统</h3>
                <p><strong>应用领域</strong>：</p>
                <ul>
                    <li>电商商品推荐</li>
                    <li>视频/音乐推荐</li>
                    <li>新闻推送</li>
                </ul>
                <p><strong>典型方法</strong>：协同过滤、内容过滤、混合推荐</p>

                <h3>7.4 工业自动化</h3>
                <p><strong>应用领域</strong>：</p>
                <ul>
                    <li>故障检测</li>
                    <li>预测性维护</li>
                    <li>质量控制</li>
                    <li>生产优化</li>
                </ul>
            </div>

            <div id="section8" class="section">
                <h2>8. 实战综合题</h2>

                <div class="tip">
                    本章包含完整的综合例题，结合多个知识点，非常适合考前练习！
                </div>

                <p>综合例题涵盖：</p>
                <ul>
                    <li>完整的机器学习项目流程</li>
                    <li>神经网络手动计算</li>
                    <li>实际问题建模与求解</li>
                </ul>
            </div>

            <div id="section9" class="section">
                <h2>9. 常见错误与调试技巧</h2>

                <h3>9.1 过拟合问题</h3>

                <div class="warning">
                    <strong>症状</strong>：<br>
                    训练准确率很高（&gt;95%），测试准确率很低（&lt;70%）
                </div>

                <p><strong>原因</strong>：</p>
                <ul>
                    <li>模型过于复杂</li>
                    <li>训练数据太少</li>
                    <li>训练时间过长</li>
                </ul>

                <p><strong>解决方法</strong>：</p>
                <ol>
                    <li><strong>正则化</strong>：在损失函数中添加惩罚项</li>
                    <li><strong>Dropout</strong>：训练时随机丢弃神经元</li>
                    <li><strong>数据增强</strong>：人工扩充训练数据</li>
                    <li><strong>早停(Early Stopping)</strong>：监控验证集性能</li>
                    <li><strong>简化模型</strong>：减少层数或神经元数量</li>
                </ol>

                <h3>9.2 梯度消失/爆炸</h3>

                <p><strong>解决方法</strong>：</p>
                <ol>
                    <li>使用ReLU激活函数（替代Sigmoid）</li>
                    <li>批量归一化(Batch Normalization)</li>
                    <li>梯度裁剪：限制梯度最大值</li>
                    <li>合理初始化权重</li>
                    <li>使用残差连接(ResNet)</li>
                </ol>

                <h3>9.3 类别不平衡</h3>

                <p><strong>问题</strong>：某一类样本数量远多于其他类</p>
                <p>例：欺诈检测中，正常交易99%，欺诈交易1%</p>

                <p><strong>解决方法</strong>：</p>
                <ol>
                    <li><strong>重采样</strong>：过采样（复制少数类）或欠采样（减少多数类）</li>
                    <li><strong>类别权重</strong>：少数类设置更高权重</li>
                    <li><strong>合成样本(SMOTE)</strong>：在少数类样本之间插值</li>
                    <li><strong>改变评估指标</strong>：用F1分数或AUC代替准确率</li>
                </ol>
            </div>

            <div id="section10" class="section">
                <h2>10. 期末考试题型预测</h2>

                <h3>题型1：概念题</h3>
                <ul>
                    <li>AI三个层次的区别</li>
                    <li>监督学习vs无监督学习</li>
                    <li>过拟合vs欠拟合</li>
                    <li>精确率vs召回率</li>
                </ul>

                <h3>题型2：计算题</h3>
                <ul>
                    <li>线性回归预测</li>
                    <li>逻辑回归概率计算</li>
                    <li>神经元输出计算</li>
                    <li>K-means聚类迭代</li>
                    <li>Q-learning更新</li>
                </ul>

                <h3>题型3：分析题</h3>
                <ul>
                    <li>给定混淆矩阵，计算评估指标</li>
                    <li>分析模型性能，提出改进建议</li>
                    <li>解释算法工作原理</li>
                </ul>

                <h3>题型4：应用题</h3>
                <ul>
                    <li>选择合适的算法解决实际问题</li>
                    <li>设计机器学习系统</li>
                    <li>分析自动化场景</li>
                </ul>
            </div>

            <div id="section11" class="section">
                <h2>11. 快速记忆口诀</h2>

                <div class="tip">
                    <strong>机器学习三大类</strong>：<br>
                    监督有标签，分类和回归<br>
                    无监督无标签，聚类和降维<br>
                    强化有奖惩，策略要学习
                </div>

                <div class="tip">
                    <strong>神经网络激活函数</strong>：<br>
                    ReLU最常用，负数全归零<br>
                    Sigmoid变概率，范围零到一<br>
                    Tanh更陡峭，范围负一正一
                </div>

                <div class="tip">
                    <strong>防止过拟合五法</strong>：<br>
                    数据要增多<br>
                    正则来惩罚<br>
                    Dropout随机删<br>
                    早停要及时<br>
                    模型要简化
                </div>

                <div class="tip">
                    <strong>评估指标记忆</strong>：<br>
                    准确率看全局<br>
                    精确率看预测<br>
                    召回率看实际<br>
                    F1综合评价
                </div>
            </div>

            <div id="section12" class="section">
                <h2>12. 重点公式汇总</h2>

                <div class="formula-box">
                    <h4>线性回归</h4>
                    <div class="formula">
                        y = w₁x₁ + w₂x₂ + ... + wₙxₙ + b<br>
                        MSE = (1/m)Σ(yᵢ - ŷᵢ)²
                    </div>
                </div>

                <div class="formula-box">
                    <h4>逻辑回归</h4>
                    <div class="formula">
                        P(y=1|x) = 1/(1+e<sup>-z</sup>)<br>
                        z = w₁x₁ + w₂x₂ + ... + wₙxₙ + b
                    </div>
                </div>

                <div class="formula-box">
                    <h4>梯度下降</h4>
                    <div class="formula">
                        w = w - α×(∂Loss/∂w)
                    </div>
                </div>

                <div class="formula-box">
                    <h4>神经网络</h4>
                    <div class="formula">
                        z = Σwᵢxᵢ + b<br>
                        a = activation(z)
                    </div>
                </div>

                <div class="formula-box">
                    <h4>Q-Learning</h4>
                    <div class="formula">
                        Q(s,a) = Q(s,a) + α[r + γ×max Q(s',a') - Q(s,a)]
                    </div>
                </div>

                <div class="formula-box">
                    <h4>欧氏距离</h4>
                    <div class="formula">
                        d = √[(x₁-y₁)² + (x₂-y₂)² + ...]
                    </div>
                </div>

                <div class="formula-box">
                    <h4>评估指标</h4>
                    <div class="formula">
                        Accuracy = (TP+TN)/(TP+TN+FP+FN)<br>
                        Precision = TP/(TP+FP)<br>
                        Recall = TP/(TP+FN)<br>
                        F1 = 2×(P×R)/(P+R)
                    </div>
                </div>
            </div>

            <div id="section13" class="section">
                <h2>13. 学习建议</h2>

                <ol>
                    <li><strong>理解概念</strong>：不要死记公式，理解背后原理</li>
                    <li><strong>多做练习</strong>：手动计算例题，加深印象</li>
                    <li><strong>画图辅助</strong>：神经网络、决策树都适合画图理解</li>
                    <li><strong>联系实际</strong>：想想每个算法的应用场景</li>
                    <li><strong>对比记忆</strong>：把相似概念放在一起对比（如精确率vs召回率）</li>
                </ol>
            </div>

            <div id="section14" class="section">
                <h2>14. 考前检查清单</h2>

                <ul class="checklist">
                    <li>能解释监督/无监督/强化学习的区别</li>
                    <li>会计算线性回归和逻辑回归</li>
                    <li>理解神经网络的前向传播</li>
                    <li>会计算混淆矩阵和评估指标</li>
                    <li>理解过拟合和解决方法</li>
                    <li>会进行K-means聚类迭代</li>
                    <li>理解Q-learning更新过程</li>
                    <li>能识别不同场景适用的算法</li>
                    <li>会分析模型性能并提出改进</li>
                </ul>

                <div class="tip" style="margin-top: 30px; font-size: 1.2em; text-align: center;">
                    <strong>祝您考试顺利！记住：理解 &gt; 记忆，应用 &gt; 理论！</strong>
                </div>
            </div>
        </div>
    </div>

    <a href="#" class="back-to-top">↑</a>

    <footer style="background: #2c3e50; color: white; text-align: center; padding: 30px; margin-top: 40px;">
        <p style="font-size: 1.1em; margin-bottom: 10px;">📚 祝您考试顺利，取得优异成绩！</p>
        <p style="opacity: 0.8; font-size: 0.95em;">作者：冷歌 | 用心整理，助力学习</p>
    </footer>

    <script>
        // 平滑滚动
        document.querySelectorAll('a[href^="#"]').forEach(anchor => {
            anchor.addEventListener('click', function (e) {
                e.preventDefault();
                const target = document.querySelector(this.getAttribute('href'));
                if (target) {
                    target.scrollIntoView({
                        behavior: 'smooth',
                        block: 'start'
                    });
                }
            });
        });

        // 高亮当前章节
        window.addEventListener('scroll', function() {
            const sections = document.querySelectorAll('.section');
            const navLinks = document.querySelectorAll('.sidebar a');

            let current = '';
            sections.forEach(section => {
                const sectionTop = section.offsetTop;
                if (pageYOffset >= sectionTop - 200) {
                    current = section.getAttribute('id');
                }
            });

            navLinks.forEach(link => {
                link.style.background = '';
                link.style.color = '';
                if (link.getAttribute('href') === '#' + current) {
                    link.style.background = '#667eea';
                    link.style.color = 'white';
                }
            });
        });

        // 打印功能
        function printPage() {
            window.print();
        }
    </script>
</body>
</html>